Динамическое программирование – это способ решения задач путём разделения их на меньшие, более управляемые подзадачи, и сохранения решений этих задач для последующего использования.
	
Основа динамического программирования – принцип оптимальной подструктуры: если задача делится на подзадачи, и решение каждой подзадачи является оптимальным, то и общее решение также является оптимальным. Решение каждой следующей подзадачи зависит от результатов решений предыдущих подзадач. Поэтому многие решения реализуются с применением рекурсии. Рекурсивная функция вызывает сама себя для решения части задачи, пока не достигнет базового случая – условия, при достижении которого рекурсия прекращается. Во избежание повторного вычисления результатов уже выполненных подзадач используется мемоизация – сохранение результатов уже выполненных подзадач. Таким образом, при очередном вызове рекурсивной функции она выполнится лишь один раз для каждой отдельной подзадачи: если же данная подзадача была выполнена ранее, результат её выполнения будет возвращён из хранилища. 
	
Big O()» - математическая нотация, используемая для обозначения зависимости верхней границы времени работы алгоритма в зависимости от объёма данных, а также может обозначать пространственную сложность – оценку потребления памяти при выполнении алгоритма. Например, О(1) означает, что время работы алгоритма не зависит от объёма входных данных, О(n) – время выполнения прямо пропорционально объёму данных и т. д.

<img width="533" height="611" alt="climbing stairs" src="https://github.com/user-attachments/assets/64126f69-4727-49fd-b83b-d11b6e36f764" />

Рисунок 1. Решение задачи Climbing stairs

Решение основано на динамическом подходе, использующем принцип Фибоначчи. Основная идея заключается в том, что каждый способ подъема на ступеньку является суммой двух предыдущих возможных путей. Достичь ступени номер i можно двумя способами:
- сделав один шаг с предыдущей ступени (i-1),
- два шага с предпредыдущей ступени (i-2).
Таким образом, количество способов попасть на каждую следующую ступень равняется сумме количества способов попадания на предыдущие две ступени.
Базовый случай: когда число ступеней меньше трёх (n < 3), возвращается сам аргумент n. Tсли лестница имеет всего одну или две ступеньки, существует ровно столько же способов подняться на неё.
Переменная first хранит общее количество способов достижения текущего уровня, а переменная second хранит количество способов достижения предшествующего уровня.

<img width="541" height="722" alt="jump game 2" src="https://github.com/user-attachments/assets/a31f800b-265b-4c12-8085-82d77f153e9f" />

Рисунок 2. Решение задачи jump game 2

Для эффективного нахождения оптимального пути используется подход рекурсивного перебора с выбором наилучшего варианта. Суть метода сводится к следующему:

Из текущей позиции выбираются возможные дальнейшие переходы (от ближайших соседей до максимальной дальности прыжка, указанной в текущей позиции).
Среди всех возможных переходов ищется тот вариант, который позволяет дальше продвинуться вперёд относительно остальных вариантов (оценивая максимум достижимого индекса следующего перехода).
Процесс повторяется рекурсивно, пока цель (последняя ячейка массива) не достигнута.

<img width="540" height="679" alt="pascal&#39;s triangle 2" src="https://github.com/user-attachments/assets/bc032729-8fef-4ce0-9ed2-03a75070797e" />

Рисунок 3. Решение задачи pascal's triangle 2

В задаче требуется получить строку треугольника Паскаля с определённым индексом. каждый элемент строки зависит от элементов предыдущей строки. 
Изначально начинается с простой базовой строки [1], представляющей вершину треугольника.
Затем на каждой последующей итерации формируется новая строка, заполняя её элементами, образованными суммированием соответствующих элементов предыдущей строки.
Так как треугольник Паскаля симметричен, и крайние элементы всегда равны единице, достаточно заполнить середину строки, зная её структуру.

<img width="611" height="673" alt="решение" src="https://github.com/user-attachments/assets/86187344-a895-4efc-8641-321060a2f405" />

Рисунок 4. Решение задачи best time to buy and sell stock 1

Для решения этой задачи на каждом шаге нужно отслеживать минимальное значение акции: именно такое значение подходит для дня покупки акции. 
Затем выполняется проверка: превышает ли текущая разница между стоимостью продажи в день i и покупкой в день, когда акция имеет минимальную цену; если да, то значение разницы max_diff обновляется.
Сначала за максимальную прибыль принимается 0, за минимальноое значение цены акции - первый элемент массива.
Выполнение рекурсии завершается, когда обработаны все элементы массива (достигнут последний индекс)

<img width="554" height="635" alt="best time to buy and sell stock 2" src="https://github.com/user-attachments/assets/af3944d5-1313-4a93-8ffa-497566712017" />

Рисунок 5. Решение задачи best time to buy and sell stock 2

Эта задача отличается от предыдущей тем, что предусмотрена возможность выполнять неограниченное количество операций покупки и продажи.
На каждом шаге отслеживаются периоды роста курса акций, в рамках которых фиксируется прибыль как разница между наивысшей и низшей точкой в данном отрезке времени.
Если цена повышается, продолжается фиксация текущего максимального значения. Если текущая цена ниже предыдущей, фиксируется прибыль за этот промежуток. Новый период открывается с текущей цены, и начинается мониторинг дальнейшего роста.
Процедура заканчивается, когда все элементы просчитаны, и остаётся только добавить прибыль от последнего найденного периода.
